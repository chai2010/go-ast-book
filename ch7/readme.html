<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using https://github.com/wa-lang/wabook -->
        <meta charset="UTF-8">
        <title>第7章 复合类型 - Go语言定制指南</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../static/wabook/css/variables.css">
        <link rel="stylesheet" href="../static/wabook/css/general.css">
        <link rel="stylesheet" href="../static/wabook/css/chrome.css">
        <link rel="stylesheet" href="../static/wabook/css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../static/wabook/FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../static/wabook/fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../static/wabook/highlight.css">
        <link rel="stylesheet" href="../static/wabook/tomorrow-night.css">
        <link rel="stylesheet" href="../static/wabook/ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('wabook-theme');
                var sidebar = localStorage.getItem('wabook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('wabook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('wabook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('wabook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('wabook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter">
  <li class="chapter-item expanded ">
    <a href="../index.html" >Go语言定制指南</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../preface.html" >前言</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch1/readme.html" ><strong aria-hidden="true">1.</strong> 第1章 记号</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch2/readme.html" ><strong aria-hidden="true">2.</strong> 第2章 基础面值</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch3/readme.html" ><strong aria-hidden="true">3.</strong> 第3章 基础表达式</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch4/readme.html" ><strong aria-hidden="true">4.</strong> 第4章 代码结构</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch5/readme.html" ><strong aria-hidden="true">5.</strong> 第5章 通用声明</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch6/readme.html" ><strong aria-hidden="true">6.</strong> 第6章 函数声明</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch7/readme.html" class="active"><strong aria-hidden="true">7.</strong> 第7章 复合类型</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch8/readme.html" ><strong aria-hidden="true">8.</strong> 第8章 复合面值</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch9/readme.html" ><strong aria-hidden="true">9.</strong> 第9章 复合表达式</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch10/readme.html" ><strong aria-hidden="true">10.</strong> 第10章 语句块和语句</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch11/readme.html" ><strong aria-hidden="true">11.</strong> 第11章 类型检查</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch12/readme.html" ><strong aria-hidden="true">12.</strong> 第12章 语义信息</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch13/readme.html" ><strong aria-hidden="true">13.</strong> 第13章 SSA形式</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch14/readme.html" ><strong aria-hidden="true">14.</strong> 第14章 凹语言</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch15/readme.html" ><strong aria-hidden="true">15.</strong> 第15章 LLVM简介</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../ch16/readme.html" ><strong aria-hidden="true">16.</strong> 第16章 LLVM实例</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../appendix/a-goyacc/readme.html" >附录A goyacc</a>
  </li>
  <li class="chapter-item expanded ">
    <a href="../appendix/b-antlr4/readme.html" >附录B ANTLR4</a>
  </li>
</ol>

            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title"><a href="../index.html">Go语言定制指南</a></h1>

                    <div class="right-buttons">
                        <a href="https://github.com/chai2010/go-ast-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/chai2010/go-ast-book/edit/master/ch7/readme.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>

                    <main>
                        <ul dir="auto"><li><em>凹语言(Go实现, 面向WASM设计): <a href="https://github.com/wa-lang/wa">https://github.com/wa-lang/wa</a></em></li><li><em>WaBook(Go语言实现的MD电子书构建工具): <a href="https://github.com/wa-lang/wabook">https://github.com/wa-lang/wabook</a></em></li></ul><hr>

                        <h1>第7章 复合类型</h1>
<p>这里讨论的复合类型是指无法用一个标识符表示的类型，它们包含其它包中的基础类型（需要通过点号选择操作符）、指针类型、
数组类型、切片类型、结构体类型、map类型、管道类型、函数类型和接口类型，以及它们之间再次组合产生的更复杂的类型。</p>
<h2>7.1 类型的语法</h2>
<p>在基础类型声明章节我们已经简要学习过类型的声明语法规范，不过当时只讨论了基于标识符的简单声明。本章我们将继续探讨复合类型声明的语法和语法树的表示。以下是更为完整的类型声明的语法规范：</p>
<pre><code class="language-bnf">TypeDecl  = &quot;type&quot; ( TypeSpec | &quot;(&quot; { TypeSpec &quot;;&quot; } &quot;)&quot; ) .
TypeSpec  = AliasDecl | TypeDef .

AliasDecl = identifier &quot;=&quot; Type .
TypeDef   = identifier Type .

Type      = TypeName | TypeLit | &quot;(&quot; Type &quot;)&quot; .
TypeName  = identifier | PackageName &quot;.&quot; identifier .
TypeLit   = PointerType | ArrayType | SliceType
          | StructType | MapType | ChannelType
          | FunctionType | InterfaceType
          .
</code></pre>
<p>增加的部分主要在TypeName和TypeLit。TypeName不仅仅可以从当前空间的标识符定义新类型，还支持从其它包导入的标识符定义类型。而TypeLit表示类型面值，比如基于已有类型的指针，或者是匿名的结构体都属于类型的面值。</p>
<p>如前文所描述，类型定义由<code>*ast.TypeSpec</code>结构体表示，复合类型也是如此。下面再来回顾下该结构体的定义：</p>
<pre><code class="language-go">type TypeSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Name    *Ident        // type name
	Assign  token.Pos     // position of '=', if any; added in Go 1.9
	Type    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of th *XxxTypes
	Comment *CommentGroup // line comments; or nil
}
</code></pre>
<p>其中Name成员表示给类型命名，Type通过特殊的类型表达式表示类型的定义，此外如果Assign被设置则表示声明的是类型的别名。</p>
<h2>7.2 基础类型</h2>
<p>基础类型是最简单的类型，就是基于已有的命名类型再次定义新类型，或者是为已有类型定义新的别名。该类型的语法规则比较简单，主要限制在Type部分：</p>
<pre><code>TypeDecl  = &quot;type&quot; ( TypeSpec | &quot;(&quot; { TypeSpec &quot;;&quot; } &quot;)&quot; ) .
TypeSpec  = AliasDecl | TypeDef .

AliasDecl = identifier &quot;=&quot; Type .
TypeDef   = identifier Type .

Type      = identifier | PackageName &quot;.&quot; identifier .
</code></pre>
<p>Type表示已有的命名类型，可以是当前包的类型，也可以是其它包的类型。下面是这些类型的例子：</p>
<pre><code class="language-go">type Int1 int
type Int2 pkg.Int
</code></pre>
<p>其中第一个Int1类型是基于当前名字空间可以直接访问的int类型，而第二个Int2类型是基于导入的pkg包中的Int类型。我们可以用以下代码解析上面的类型声明：</p>
<pre><code class="language-go">func main() {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, &quot;hello.go&quot;, src, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	for _, decl := range f.Decls {
		ast.Print(nil, decl.(*ast.GenDecl).Specs[0])
	}
}

const src = `package foo
type Int1 int
type Int2 pkg.int
`
</code></pre>
<p>第一个类型的输出结果如下：</p>
<pre><code> 0  *ast.TypeSpec {
 1  .  Name: *ast.Ident {
 2  .  .  NamePos: 18
 3  .  .  Name: &quot;Int1&quot;
 4  .  .  Obj: *ast.Object {
 5  .  .  .  Kind: type
 6  .  .  .  Name: &quot;Int1&quot;
 7  .  .  .  Decl: *(obj @ 0)
 8  .  .  }
 9  .  }
10  .  Assign: 0
11  .  Type: *ast.Ident {
12  .  .  NamePos: 23
13  .  .  Name: &quot;int&quot;
14  .  }
15  }
</code></pre>
<p>第二个类型的输出结果如下：</p>
<pre><code> 0  *ast.TypeSpec {
 1  .  Name: *ast.Ident {
 2  .  .  NamePos: 32
 3  .  .  Name: &quot;Int2&quot;
 4  .  .  Obj: *ast.Object {
 5  .  .  .  Kind: type
 6  .  .  .  Name: &quot;Int2&quot;
 7  .  .  .  Decl: *(obj @ 0)
 8  .  .  }
 9  .  }
10  .  Assign: 0
11  .  Type: *ast.SelectorExpr {
12  .  .  X: *ast.Ident {
13  .  .  .  NamePos: 37
14  .  .  .  Name: &quot;pkg&quot;
15  .  .  }
16  .  .  Sel: *ast.Ident {
17  .  .  .  NamePos: 41
18  .  .  .  Name: &quot;int&quot;
19  .  .  }
20  .  }
21  }
</code></pre>
<p>对比两个结果可以发现，Int1的Type定义对应的是<code>*ast.Ident</code>表示一个标识符，而Int2的Type定义对应的是<code>*ast.SelectorExpr</code>表示是其它包的命名类型。<code>*ast.SelectorExp</code>结构体定义如下：</p>
<pre><code class="language-go">type SelectorExpr struct {
	X   Expr   // expression
	Sel *Ident // field selector
}
</code></pre>
<p>结构体X成员被定义为Expr接口类型，不过根据当前的语法必须是一个标识符类型（之所以被定义为表达式接口，是因为其它的表达式会复用这个结构体）。Sel成员被定义为标识符类型，表示被选择的标识符名字。</p>
<h2>7.3 指针类型</h2>
<p>指针是操作底层类型时最强有力的武器，只要有指针就可以操作内存上的所有数据。最简单的是一级指针，然后再扩展出二级和更多级指针。以下是Go语言指针类型的语法规范：</p>
<pre><code>PointerType = &quot;*&quot; BaseType .
BaseType    = Type .

Type        = TypeName | TypeLit | &quot;(&quot; Type &quot;)&quot; .
...
</code></pre>
<p>指针类型以星号<code>*</code>开头，后面是BaseType定义的类型表达式。从语法规范角度看，Go语言没有单独定义多级指针，只有一种指向BaseType类型的一级指针。但是PointerType又可以作为TypeLit类型面值被重新用作BaseType，这就产生了多级指针的语法。</p>
<p>下面是一级指针语法树解析的例子：</p>
<pre><code class="language-go">func main() {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, &quot;hello.go&quot;, src, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	for _, decl := range f.Decls {
		ast.Print(nil, decl.(*ast.GenDecl).Specs[0])
	}
}

const src = `package foo
type IntPtr *int
`
</code></pre>
<p>解析的结果如下：</p>
<pre><code> 0  *ast.TypeSpec {
 1  .  Name: *ast.Ident {
 2  .  .  NamePos: 18
 3  .  .  Name: &quot;IntPtr&quot;
 4  .  .  Obj: *ast.Object {
 5  .  .  .  Kind: type
 6  .  .  .  Name: &quot;IntPtr&quot;
 7  .  .  .  Decl: *(obj @ 0)
 8  .  .  }
 9  .  }
10  .  Assign: 0
11  .  Type: *ast.StarExpr {
12  .  .  Star: 25
13  .  .  X: *ast.Ident {
14  .  .  .  NamePos: 26
15  .  .  .  Name: &quot;int&quot;
16  .  .  }
17  .  }
18  }
</code></pre>
<p>新类型的名字依然是普通的<code>*ast.Ident</code>标识符类型，其值是新类型的名字“IntPtr”。而<code>ast.TypeSpec.Type</code>成员则是新的<code>*ast.StarExpr</code>类型，其结构体定义如下：</p>
<pre><code class="language-go">type StarExpr struct {
	Star token.Pos // position of &quot;*&quot;
	X    Expr      // operand
}
</code></pre>
<p>指针指向的X类型是一个递归定义的类型表达式。在这个例子中X就是一个<code>*ast.Ident</code>标识符类型表示的int，因此IntPtr类型是一个指向int类型的指针类型。</p>
<p>指针是一种天然递归定义的类型。我们可以再定义一个指向IntPtr类型的指针，它又是一个指向int类型的二级指针。但是在语法树表示时，指向IntPtr类型的一级指针和指向int类型的二级指针结构是不一样的，因为语法树解析器会将IntPtr和int都作为普通类型同等对待（语法树解析器只知道这是指向IntPtr类型的一级指针，而不知道它也是指向int类型的二级指针）。</p>
<p>下面的例子依然是在int类型基础之上定义二级指针：</p>
<pre><code class="language-go">type IntPtrPtr **int
</code></pre>
<p>解析后语法树发生的最大的差异在类型定义部分：</p>
<pre><code>11  .  Type: *ast.StarExpr {
12  .  .  Star: 28
13  .  .  X: *ast.StarExpr {
14  .  .  .  Star: 29
15  .  .  .  X: *ast.Ident {
16  .  .  .  .  NamePos: 30
17  .  .  .  .  Name: &quot;int&quot;
18  .  .  .  }
19  .  .  }
20  .  }
</code></pre>
<p>现在<code>ast.StarExpr.X</code>不再是一个<code>*ast.Ident</code>标识符类型，而是变成了<code>*ast.StarExpr</code>类型的指针类型。对于多级指针的<code>*ast.StarExpr</code>类型很像一个单向的链表，其中X成员指向的是减一级指针的<code>*ast.StarExpr</code>结点，链表的尾结点是一个<code>*ast.Ident</code>标识符类型。</p>
<h2>7.4 数组类型</h2>
<p>在传统的C/C++语言中，数组是和指针近似等同的类型，特别在传递参数时只传递数组的首地址。Go语言的数组类型是一种值类型，每次传递数组参数或者赋值都是生成数组的拷贝。但是从数组的语法定义角度看，它和指针类型也是非常相似的。以下是数组类型的语法规范：</p>
<pre><code>ArrayType   = &quot;[&quot; ArrayLength &quot;]&quot; ElementType .
ArrayLength = Expression .
ElementType = Type .
</code></pre>
<p>Go语言中数组的长度也是其类型的组成部分，数组长度是由一个表达式定义（在语义层面这个表达式必须是常量）。然后是数组元素的类型。如果抛开数组的长度部分的差异，数组类型和指针类型是非常相似的语法结构。数组元素部分的ElementType类型也可以是数组，这又构成了多级数组的语法规范。</p>
<p>下面是简单的一维整型数组的例子：</p>
<pre><code class="language-go">type IntArray [1]int
</code></pre>
<p>解析结果如下：</p>
<pre><code> 0  *ast.TypeSpec {
 1  .  Name: *ast.Ident {
 2  .  .  NamePos: 18
 3  .  .  Name: &quot;IntArray&quot;
 4  .  .  Obj: *ast.Object {
 5  .  .  .  Kind: type
 6  .  .  .  Name: &quot;IntArray&quot;
 7  .  .  .  Decl: *(obj @ 0)
 8  .  .  }
 9  .  }
10  .  Assign: 0
11  .  Type: *ast.ArrayType {
12  .  .  Lbrack: 27
13  .  .  Len: *ast.BasicLit {
14  .  .  .  ValuePos: 28
15  .  .  .  Kind: INT
16  .  .  .  Value: &quot;1&quot;
17  .  .  }
18  .  .  Elt: *ast.Ident {
19  .  .  .  NamePos: 30
20  .  .  .  Name: &quot;int&quot;
21  .  .  }
22  .  }
23  }
</code></pre>
<p>数组的类型主要由<code>*ast.ArrayType</code>类型定义。数组的长度是一个<code>*ast.BasicLit</code>类型的表达式，也就是长度为1的数组。数组元素的长度是<code>*ast.Ident</code>类型的标识符表示，数组的元素对应int类型。</p>
<p>完整的<code>*ast.ArrayType</code>结构体如下：</p>
<pre><code class="language-go">type ArrayType struct {
	Lbrack token.Pos // position of &quot;[&quot;
	Len    Expr      // Ellipsis node for [...]T array types, nil for slice types
	Elt    Expr      // element type
}
</code></pre>
<p>其中<code>ast.ArrayType.Len</code>成员是一个表示数组长度的表达式，该表达式必须可以产生常量的整数结果（也可以是三个点省略号表示从元素个数提取）。数组的元素由<code>ast.ArrayType.Elt</code>定义，其值对应一个类型表达式。和指针类型一样，数组类型也是可以递归定义的，数组的元素类型可以数数组、指针等其它任何类型。</p>
<p>同样，我们可以定义一个二维数组：</p>
<pre><code class="language-go">type IntArrayArray [1][2]int
</code></pre>
<p>解析结果如下：</p>
<pre><code>11  .  Type: *ast.ArrayType {
12  .  .  Lbrack: 32
13  .  .  Len: *ast.BasicLit {
14  .  .  .  ValuePos: 33
15  .  .  .  Kind: INT
16  .  .  .  Value: &quot;1&quot;
17  .  .  }
18  .  .  Elt: *ast.ArrayType {
19  .  .  .  Lbrack: 35
20  .  .  .  Len: *ast.BasicLit {
21  .  .  .  .  ValuePos: 36
22  .  .  .  .  Kind: INT
23  .  .  .  .  Value: &quot;2&quot;
24  .  .  .  }
25  .  .  .  Elt: *ast.Ident {
26  .  .  .  .  NamePos: 38
27  .  .  .  .  Name: &quot;int&quot;
28  .  .  .  }
29  .  .  }
30  .  }
</code></pre>
<p>同样，数组元素的类型也变成了嵌套的数组类型。N维的数组类型的语法树也类似一个单向链表结构，后<code>N-1</code>维的数组的元素也是<code>*ast.ArrayType</code>类型，最后的尾结点对应一个<code>*ast.Ident</code>标识符（也可以是其它面值类型）。</p>
<h2>7.5 切片类型</h2>
<p>Go语言中切片是简化的数组，切片中引入了诸多数组不支持的语法。不过对于切片类型的定义来说，切片和数组的差异就是省略了数组的长度而已。切片类型声明的语法规则如下：</p>
<pre><code>SliceType   = &quot;[&quot; &quot;]&quot; ElementType .
ElementType = Type .
</code></pre>
<p>下面例子是定义一个int切片：</p>
<pre><code class="language-go">type IntSlice []int
</code></pre>
<p>对其解析语法树的输出如下：</p>
<pre><code> 0  *ast.TypeSpec {
 1  .  Name: *ast.Ident {
 2  .  .  NamePos: 18
 3  .  .  Name: &quot;IntSlice&quot;
 4  .  .  Obj: *ast.Object {
 5  .  .  .  Kind: type
 6  .  .  .  Name: &quot;IntSlice&quot;
 7  .  .  .  Decl: *(obj @ 0)
 8  .  .  }
 9  .  }
10  .  Assign: 0
11  .  Type: *ast.ArrayType {
12  .  .  Lbrack: 27
13  .  .  Elt: *ast.Ident {
14  .  .  .  NamePos: 29
15  .  .  .  Name: &quot;int&quot;
16  .  .  }
17  .  }
18  } 
</code></pre>
<p>切片和数组一样，也是通过<code>*ast.ArrayType</code>结构表示切片，不过Len长度成员为nil类型（切片必须是nil，如果是0则表示是数组类型）。</p>
<h2>7.6 结构体类型</h2>
<p>结构体类型是数组类型的再次演进：数组是类型相同的元素的组合，并通过下标索引定位元素；而结构体类型是不同类型元素的组合，可以通过名字来定位元素。结构体类型这种可以组合异构元素类型的抽象能力极大地改进了数据结构编程的体验。结构体类型的语法规范定义如下：</p>
<pre><code>StructType     = &quot;struct&quot; &quot;{&quot; { FieldDecl &quot;;&quot; } &quot;}&quot; .
FieldDecl      = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField  = [ &quot;*&quot; ] TypeName .
Tag            = string_lit .

IdentifierList = identifier { &quot;,&quot; identifier } .
TypeName       = identifier | PackageName &quot;.&quot; identifier .
</code></pre>
<p>结构体通过struct关键字开始定义，然后在大括弧中包含成员的定义。每一个FieldDecl表示一组有着相同类型和Tag字符串的标识符名字，或者是嵌入的匿名类型或类型指针。以下是结构体的例子：</p>
<pre><code class="language-go">type MyStruct struct {
	a, b int &quot;int value&quot;
	string
}
</code></pre>
<p>其中a和b成员不仅仅有着相同的int类型，同时还有着相同的Tag字符串，最后的成员是嵌入一个匿名的字符串。</p>
<p>对其解析语法树的输出如下（为了简化省略了一些无关的信息）：</p>
<pre><code>11  .  Type: *ast.StructType {
12  .  .  Struct: 27
13  .  .  Fields: *ast.FieldList {
14  .  .  .  Opening: 34
15  .  .  .  List: []*ast.Field (len = 2) {
16  .  .  .  .  0: *ast.Field {
17  .  .  .  .  .  Names: []*ast.Ident (len = 2) {
18  .  .  .  .  .  .  0: *ast.Ident {
19  .  .  .  .  .  .  .  NamePos: 37
20  .  .  .  .  .  .  .  Name: &quot;a&quot;
21  .  .  .  .  .  .  .  Obj: *ast.Object {...}
26  .  .  .  .  .  .  }
27  .  .  .  .  .  .  1: *ast.Ident {
28  .  .  .  .  .  .  .  NamePos: 40
29  .  .  .  .  .  .  .  Name: &quot;b&quot;
30  .  .  .  .  .  .  .  Obj: *ast.Object {...}
35  .  .  .  .  .  .  }
36  .  .  .  .  .  }
37  .  .  .  .  .  Type: *ast.Ident {
38  .  .  .  .  .  .  NamePos: 42
39  .  .  .  .  .  .  Name: &quot;int&quot;
40  .  .  .  .  .  }
41  .  .  .  .  .  Tag: *ast.BasicLit {
42  .  .  .  .  .  .  ValuePos: 46
43  .  .  .  .  .  .  Kind: STRING
44  .  .  .  .  .  .  Value: &quot;\&quot;int value\&quot;&quot;
45  .  .  .  .  .  }
46  .  .  .  .  }
47  .  .  .  .  1: *ast.Field {
48  .  .  .  .  .  Type: *ast.Ident {
49  .  .  .  .  .  .  NamePos: 59
50  .  .  .  .  .  .  Name: &quot;string&quot;
51  .  .  .  .  .  }
52  .  .  .  .  }
53  .  .  .  }
54  .  .  .  Closing: 66
55  .  .  }
56  .  .  Incomplete: false
57  .  }
</code></pre>
<p>所有的结构体成员由<code>*ast.FieldList</code>表示，其中有三个<code>*ast.Field</code>元素。第一个<code>*ast.Field</code>对应<code>a, b int &quot;int value&quot;</code>的成员声明，包含了成员名字列表、类型和Tag信息。最后的<code>*ast.Field</code>是嵌入的string成员，只有普通的名字而没有类型信息（匿名嵌入成员也可以单独定义Tag字符串）。</p>
<p>其中<code>ast.StructType</code>等和结构体相关的语法树结构定义如下：</p>
<pre><code class="language-go">type StructType struct {
	Struct     token.Pos  // position of &quot;struct&quot; keyword
	Fields     *FieldList // list of field declarations
	Incomplete bool       // true if (source) fields are missing in the Fields list
}
type FieldList struct {
	Opening token.Pos // position of opening parenthesis/brace, if any
	List    []*Field  // field list; or nil
	Closing token.Pos // position of closing parenthesis/brace, if any
}
type Field struct {
	Doc     *CommentGroup // associated documentation; or nil
	Names   []*Ident      // field/method/parameter names; or nil
	Type    Expr          // field/method/parameter type
	Tag     *BasicLit     // field tag; or nil
	Comment *CommentGroup // line comments; or nil
}
</code></pre>
<p>StructType中最重要的信息是FieldList类型的Fields成员声明列表信息。而每一组成员声明又由<code>ast.Field</code>表示，其中包含一组成员的名字，共享的类型和Tag字符串。需要注意的是，<code>ast.Field</code>不仅仅用于表示结构体成员的语法树结点，同时也用于表示接口的方法列表、函数或方法的各种参数列表（接收者参数、输入参数和返回值），因此这是一个异常重要的类型。</p>
<h2>7.7 Map类型</h2>
<p>Map其实是从数组和结构体的混合类型发展而来。Map支持根据元素的名字（也就是key）动态添加删除元素，但是其中的所有元素必须有着相同的类型。很多其它语言甚至用Map代替结构体和数组，比如Lua中以Table关联数组同时实现了数组和结构体的功能，而JavaScript中也是通过类似Map的对象来实现结构体。Go作为一个静态语言将Map直接作为语言内置的语法构造引入是一个比较大胆激进的行为，但同时也简化了相关数据结构的编程（因为内置的语法增加了部分泛型的功能，大大提升了编程体验）。</p>
<p>Map类型的语法规范定义比较简单：</p>
<pre><code>MapType = &quot;map&quot; &quot;[&quot; KeyType &quot;]&quot; ElementType .
KeyType = Type .
</code></pre>
<p>首先以map关键字开始，然后通过中括弧包含Key的类型，最后是元素的类型。需要注意的是，Map中的Key必须是可进行相等比较的类型（典型的切片就不能作为Key类型），但是在语法树解析阶段并不会做这类检查。</p>
<p>下面是基于map定义的新类型：</p>
<pre><code class="language-go">type IntStringMap map[int]string
</code></pre>
<p>解析的语法树输出如下：</p>
<pre><code>11  .  Type: *ast.MapType {
12  .  .  Map: 31
13  .  .  Key: *ast.Ident {
14  .  .  .  NamePos: 35
15  .  .  .  Name: &quot;int&quot;
16  .  .  }
17  .  .  Value: *ast.Ident {
18  .  .  .  NamePos: 39
19  .  .  .  Name: &quot;string&quot;
20  .  .  }
21  .  }
</code></pre>
<p>虽然Map功能强大，但是表示其类型的语法树比较简单。其中Key和Value部分都是类型表达式，这个例子中分别是int和string标识符。</p>
<p>下面是<code>ast.MapType</code>语法树结点的定义：</p>
<pre><code class="language-go">type MapType struct {
	Map   token.Pos // position of &quot;map&quot; keyword
	Key   Expr
	Value Expr
}
</code></pre>
<p>其中Key和Value部分都是类型表达式，可以是其它更复杂的组合类型。</p>
<h2>7.8 管道类型</h2>
<p>管道是Go语言比较有特色的类型，管道有双向管道、只写管道和只读管道之分，同时管道有元素类型。管道类型的语法规范如下：</p>
<pre><code>ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType .
</code></pre>
<p>在语法树中管道类型由<code>ast.ChanType</code>结构体定义：</p>
<pre><code class="language-go">type ChanType struct {
	Begin token.Pos // position of &quot;chan&quot; keyword or &quot;&lt;-&quot; (whichever comes first)
	Arrow token.Pos // position of &quot;&lt;-&quot; (token.NoPos if there is no &quot;&lt;-&quot;); added in Go 1.1
	Dir   ChanDir   // channel direction
	Value Expr      // value type
}

type ChanDir int

const (
	SEND ChanDir = 1 &lt;&lt; iota
	RECV
)
</code></pre>
<p>其中<code>ast.ChanType.Dir</code>是管道的方向，SEND表示发送、RECV表示接收、<code>SEND|RECV</code>比特位组合表示双向管道。下面的例子是一个双向的int管道：</p>
<pre><code class="language-go">type IntChan chan int
</code></pre>
<p>解析的语法树结果如下：</p>
<pre><code>11  .  Type: *ast.ChanType {
12  .  .  Begin: 26
13  .  .  Arrow: 0
14  .  .  Dir: 3
15  .  .  Value: *ast.Ident {
16  .  .  .  NamePos: 31
17  .  .  .  Name: &quot;int&quot;
18  .  .  }
19  .  }
</code></pre>
<p>其中<code>ast.ChanType.Dir</code>值是3，也就是<code>SEND|RECV</code>比特位组合，表示这是一个双向管道。而<code>ast.ChanType.Value</code>部分表示管道值的类型，这里是一个<code>ast.Ident</code>表示的int类型。</p>
<h2>7.9 函数类型</h2>
<p>函数类型基本上是函数签名部分，包含函数的输入参数和返回值类型。在函数声明一节我们已经见过函数声明的语法规范，但是函数类型不包含函数的名字。函数类型的语法规范如下：</p>
<pre><code>FunctionType   = &quot;func&quot; Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = &quot;(&quot; [ ParameterList [ &quot;,&quot; ] ] &quot;)&quot; .
ParameterList  = ParameterDecl { &quot;,&quot; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ &quot;...&quot; ] Type .
</code></pre>
<p>func关键字后面直接是输入参数和返回值列表组成的函数签名，不包含函数的名字。下面函数类型的一个例子：</p>
<pre><code class="language-go">type FuncType func(a, b int) bool
</code></pre>
<p>函数类型中类型部分也是由<code>ast.FuncType</code>结构体定义。关于函数类型的细节请参考函数声明章节。</p>
<h2>7.10 接口类型</h2>
<p>从语法结构角度看，接口和结构体类型很像，不过接口的每个成员都是函数类型。接口类型的语法规则如下：</p>
<pre><code>InterfaceType      = &quot;interface&quot; &quot;{&quot; { MethodSpec &quot;;&quot; } &quot;}&quot; .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .

Signature          = Parameters [ Result ] .
Result             = Parameters | Type .
</code></pre>
<p>接口中每个成员都是函数类型，但是函数类型部分不包含func关键字。下面是只要一个方法成员的接口：</p>
<pre><code class="language-go">type IntReader interface {
	Read() int
}
</code></pre>
<p>对齐分析语法树结果如下：</p>
<pre><code>11  .  Type: *ast.InterfaceType {
12  .  .  Interface: 28
13  .  .  Methods: *ast.FieldList {
14  .  .  .  Opening: 38
15  .  .  .  List: []*ast.Field (len = 1) {
16  .  .  .  .  0: *ast.Field {
17  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
18  .  .  .  .  .  .  0: *ast.Ident {
19  .  .  .  .  .  .  .  NamePos: 41
20  .  .  .  .  .  .  .  Name: &quot;Read&quot;
21  .  .  .  .  .  .  .  Obj: *ast.Object {
22  .  .  .  .  .  .  .  .  Kind: func
23  .  .  .  .  .  .  .  .  Name: &quot;Read&quot;
24  .  .  .  .  .  .  .  .  Decl: *(obj @ 16)
25  .  .  .  .  .  .  .  }
26  .  .  .  .  .  .  }
27  .  .  .  .  .  }
28  .  .  .  .  .  Type: *ast.FuncType {
29  .  .  .  .  .  .  Func: 0
30  .  .  .  .  .  .  Params: *ast.FieldList {
31  .  .  .  .  .  .  .  Opening: 45
32  .  .  .  .  .  .  .  Closing: 46
33  .  .  .  .  .  .  }
34  .  .  .  .  .  .  Results: *ast.FieldList {
35  .  .  .  .  .  .  .  Opening: 0
36  .  .  .  .  .  .  .  List: []*ast.Field (len = 1) {
37  .  .  .  .  .  .  .  .  0: *ast.Field {
38  .  .  .  .  .  .  .  .  .  Type: *ast.Ident {
39  .  .  .  .  .  .  .  .  .  .  NamePos: 48
40  .  .  .  .  .  .  .  .  .  .  Name: &quot;int&quot;
41  .  .  .  .  .  .  .  .  .  }
42  .  .  .  .  .  .  .  .  }
43  .  .  .  .  .  .  .  }
44  .  .  .  .  .  .  .  Closing: 0
45  .  .  .  .  .  .  }
46  .  .  .  .  .  }
47  .  .  .  .  }
48  .  .  .  }
49  .  .  .  Closing: 52
50  .  .  }
51  .  .  Incomplete: false
52  .  }
</code></pre>
<p>接口的语法树是<code>ast.InterfaceType</code>类型，其<code>Methods</code>成员列表和结构体成员的<code>*ast.FieldList</code>类型一样。下面是<code>ast.InterfaceType</code>和<code>ast.StructType</code>语法树结构的定义：</p>
<pre><code class="language-go">type InterfaceType struct {
	Interface  token.Pos  // position of &quot;interface&quot; keyword
	Methods    *FieldList // list of methods
	Incomplete bool       // true if (source) methods are missing in the Methods list
}
type StructType struct {
	Struct     token.Pos  // position of &quot;struct&quot; keyword
	Fields     *FieldList // list of field declarations
	Incomplete bool       // true if (source) fields are missing in the Fields list
}
</code></pre>
<p>对比可以发现，接口和结构体语法树结点中除了方法列表和成员列表的名字不同之外，方法和成员都是由<code>ast.FieldList</code>定义的。因此上述的接口例子和下面的结构体其实非常相似：</p>
<pre><code class="language-go">type IntReader struct {
	Read func() int
}
</code></pre>
<p>如果是结构体，那么Read成员就是一个函数类型，函数是<code>func() int</code>类型。总之在语法树层面接口和结构体可以采用相似的代码处理。</p>
<h2>7.11 组合类型</h2>
<p>复合类型最强大的地方在于通过不同组合生成更复杂的类型。但是第一步需要搞清楚基于基础类型构造的复合类型，然后才是复合类型之间的组合。在掌握了基础类型和复合类型的语法树结构之后，我们就可以解析任意复杂的类型，同时也就很容易理解Go语言中反射的类型结构。不管是数据结构还是函数都需要和类型关联，因此理解类型之后就把握了整个程序的脉络，剩下的就是向函数体中填充语句而已。</p>


                        

                        
                            <div id="giscus-container"></div>
                        

                        
                            <footer class="page-footer">
                                <span>© 2019-2022 | <a href="https://github.com/chai2010/go-ast-book">柴树杉、史斌、丁尔男</a> 保留所有权利</span>
                            </footer>
                        
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../ch6/readme.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                        
                            <!-- ../ch8/readme.html -->
                            <a rel="next" href="../ch8/readme.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../ch6/readme.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                
                    <a rel="next" href="../ch8/readme.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../static/wabook/mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../static/wabook/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../static/wabook/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../static/wabook/book.js" type="text/javascript" charset="utf-8"></script>
        
        <script type="text/javascript" charset="utf-8">
            var pagePath = "ch7/readme.md"
        </script>

        <!-- Custom JS scripts -->
        
            <script src="../static/wabook/giscus.js" type="text/javascript" charset="utf-8"></script>
        

    </body>
</html>
